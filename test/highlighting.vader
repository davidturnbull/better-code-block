" Tests for fenced_code_block.vim functionality

" Setup global configuration
Before:
  " Set up test configuration
  let g:fenced_code_block_keyword = 'highlight'
  let g:fenced_code_block_keyword_aliases = ['hl', 'hi']
  let g:fenced_code_block_fence_patterns = ['^```\(.*\)$', '^[\~]\{3,}\(.*\)$']
  let g:fenced_code_block_style = 'green'
  let g:fenced_code_block_error_style = 'red'
  let g:fenced_code_block_show_line_numbers = 0
  let g:fenced_code_block_line_number_method = 'auto'
  let g:fenced_code_block_update_delay = 0
  let g:fenced_code_block_debug = 1
  let g:fenced_code_block_custom = {}

"===============================================================================
" Tests for highlight spec extraction
"===============================================================================

Execute (Test extract_highlight_spec with double quotes):
  let line = '```python highlight="1-3,5"'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '1-3,5', result

Execute (Test extract_highlight_spec with single quotes):
  let line = "```python highlight='2,4-6'"
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '2,4-6', result

Execute (Test extract_highlight_spec without quotes):
  let line = '```python highlight=1,3,5'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '1,3,5', result

Execute (Test extract_highlight_spec with alias):
  let line = '```python hl="1-3"'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '1-3', result

Execute (Test extract_highlight_spec with no highlight):
  let line = '```python'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '', result

"===============================================================================
" Tests for highlight attribute parsing
"===============================================================================

Execute (Test parse_highlight_attribute with comma-separated values):
  let spec = '1,3,5'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 3, 5], result

Execute (Test parse_highlight_attribute with range):
  let spec = '1-3'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 2, 3], result

Execute (Test parse_highlight_attribute with mixed values):
  let spec = '1-2,4,6-8'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 2, 4, 6, 7, 8], result



Execute (Test parse_highlight_attribute with spaces):
  let spec = '1 - 3, 5'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 2, 3, 5], result

Execute (Test parse_highlight_attribute with empty spec):
  let spec = ''
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [], result

"===============================================================================
" Tests for language detection
"===============================================================================

Execute (Test language detection for standard format):
  AssertEqual 'python', fenced_code_block#test_detect_language('```python')
  AssertEqual 'javascript', fenced_code_block#test_detect_language('```javascript')
  AssertEqual 'ruby', fenced_code_block#test_detect_language('``` ruby')
  AssertEqual 'shell-bash', fenced_code_block#test_detect_language('```shell-bash')
  AssertEqual 'config.json', fenced_code_block#test_detect_language('```config.json')
  AssertEqual 'php', fenced_code_block#test_detect_language('```php highlight="1-3"')
  AssertEqual 'java', fenced_code_block#test_detect_language('```{java}')
  AssertEqual '', fenced_code_block#test_detect_language('```')

"===============================================================================
" Tests for complete parse-highlight workflow
"===============================================================================

Execute (Test full parse-highlight workflow):
  let line = '```python highlight="1,3-5"'
  let spec = fenced_code_block#extract_highlight_spec(line)
  let lines = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 3, 4, 5], lines

"===============================================================================
" Tests for style attribute parsing
"===============================================================================

Execute (Test parse_style_attributes):
  let result = fenced_code_block#test_parse_style_attributes(['cterm', 'bold', 'ctermfg', 'red', 'ctermbg', 'black'])
  AssertEqual 'bold', result.cterm
  AssertEqual 'red', result.ctermfg
  AssertEqual 'black', result.ctermbg

"===============================================================================
" Tests for line number method determination
"===============================================================================

Execute (Test determine_line_number_method):
  " Test with explicit method
  let g:fenced_code_block_line_number_method = 'sign'
  AssertEqual 'sign', fenced_code_block#test_determine_line_number_method()
  
  let g:fenced_code_block_line_number_method = 'prop'
  AssertEqual 'prop', fenced_code_block#test_determine_line_number_method()
  
  " Reset to auto - the actual result depends on Vim/Neovim version
  let g:fenced_code_block_line_number_method = 'auto'
  let result = fenced_code_block#test_determine_line_number_method()
  Assert result =~ '\(nvim\|prop\|sign\)'

"===============================================================================
" Tests for code block finding
"===============================================================================

Execute (Test find_code_blocks function):
  " Create a temporary buffer with markdown content
  new
  call setline(1, [
        \ '# Test Markdown',
        \ '',
        \ '```python highlight="1,3"',
        \ 'def hello():',
        \ '    print("Hello")',
        \ '    return True',
        \ '```',
        \ '',
        \ 'Some text',
        \ '',
        \ '```javascript',
        \ 'function test() {',
        \ '  console.log("test");',
        \ '}',
        \ '```'
        \ ])

  " Get code blocks from the wrapper function
  " Check a few key properties of the blocks
  let blocks = fenced_code_block#test_find_code_blocks()
  
  " Debug output
  echom "Found " . len(blocks) . " code blocks"
  for i in range(len(blocks))
    echom "Block " . i . ": " . string(blocks[i])
  endfor
  
  " Basic validation - we should have 2 blocks
  Assert len(blocks) == 2, 'Expected 2 code blocks, found ' . len(blocks)
  
  " Check first block
  AssertEqual 'python', blocks[0].language
  
  " Check second block
  AssertEqual 'javascript', blocks[1].language
  
  " Check highlight lines in first block
  AssertEqual [1, 3], blocks[0].highlight_lines
  
  " Clean up
  bwipeout!

"===============================================================================
" Tests for parse_highlight_spec integration
"===============================================================================

Execute (Test parse_highlight_spec with different formats):
  AssertEqual [1, 3], fenced_code_block#parse_highlight_spec('```python highlight="1,3"')
  AssertEqual [1, 2, 3], fenced_code_block#parse_highlight_spec('```python highlight="1-3"')

  AssertEqual [], fenced_code_block#parse_highlight_spec('```python')

"===============================================================================
" Tests for highlight style application
"===============================================================================

Execute (Test apply_main_highlight_style):
  " Setup and apply green style
  let g:fenced_code_block_style = 'green'
  call fenced_code_block#setup_highlight_style()
  
  " Basic verification - check that highlight group exists
  let hl_id = hlID('MarkdownCodeHighlight')
  Assert hl_id > 0, 'Highlight group was not created'

"===============================================================================
" Tests for custom highlight styles
"===============================================================================

Execute (Test custom highlight styles):
  " Register a custom style
  let g:fenced_code_block_custom = {}
  call fenced_code_block#register_custom_style('test_custom', 'cterm', 'bold,underline', 'ctermfg', 'cyan', 'guifg', '#00FFFF')
  
  " Verify the style was registered
  Assert has_key(g:fenced_code_block_custom, 'test_custom')
  AssertEqual 'bold,underline', g:fenced_code_block_custom['test_custom']['cterm']
  AssertEqual 'cyan', g:fenced_code_block_custom['test_custom']['ctermfg']
  AssertEqual '#00FFFF', g:fenced_code_block_custom['test_custom']['guifg']

"===============================================================================
" Tests for error highlight style
"===============================================================================

Execute (Test error highlight style):
  " Test the 'red' error style
  let g:fenced_code_block_error_style = 'red'
  call fenced_code_block#setup_highlight_style()
  
  " Basic verification
  let hl_id = hlID('MarkdownCodeHighlightError')
  Assert hl_id > 0, 'Error highlight group was not created'

"===============================================================================
" Tests for style completion
"===============================================================================

Execute (Test style completion):
  " Register some custom styles for testing completion
  let g:fenced_code_block_custom = {}
  call fenced_code_block#register_custom_style('test_style1', 'cterm', 'bold')
  call fenced_code_block#register_custom_style('test_style2', 'cterm', 'italic')
  
  " Test completion with empty prefix
  let completions = fenced_code_block#complete_styles('', '', 0)
  Assert index(completions, 'green') >= 0, 'Built-in style missing from completions'
  Assert index(completions, 'test_style1') >= 0, 'Custom style missing from completions'
  
  " Test completion with prefix
  let completions = fenced_code_block#complete_styles('b', '', 0)
  Assert index(completions, 'blue') >= 0, 'Blue missing from prefix completions'
  Assert index(completions, 'bold') >= 0, 'Bold missing from prefix completions'
  Assert index(completions, 'green') < 0, 'Green incorrectly included in prefix completions'

"===============================================================================
" Tests for highlight line specification validation
"===============================================================================

Execute (Test validate_highlight_lines):
  " Test valid line numbers
  let b:mch_has_errors = 0
  call fenced_code_block#test_validate_highlight_lines([1, 2, 3], 5, 10)
  Assert !b:mch_has_errors, 'Valid line numbers incorrectly flagged as invalid'
  
  " Test invalid line numbers
  let b:mch_has_errors = 0
  call fenced_code_block#test_validate_highlight_lines([1, 6, 3], 5, 10)
  Assert b:mch_has_errors, 'Invalid line number not detected'
  
  let b:mch_has_errors = 0
  call fenced_code_block#test_validate_highlight_lines([0, 2, 3], 5, 10)
  Assert b:mch_has_errors, 'Zero line number not detected as invalid'
  
  let b:mch_has_errors = 0
  call fenced_code_block#test_validate_highlight_lines([-1, 2, 3], 5, 10)
  Assert b:mch_has_errors, 'Negative line number not detected as invalid'

"===============================================================================
" Tests for line number toggling
"===============================================================================

Execute (Test line number toggling functions):
  " Store original values to restore later
  let orig_show = g:fenced_code_block_show_line_numbers
  let orig_method = g:fenced_code_block_line_number_method
  
  " Test cycling through line number options
  let g:fenced_code_block_show_line_numbers = 'never'
  let g:fenced_code_block_line_number_method = 'sign'
  
  " Start with 'never' and toggle to 'always'
  call fenced_code_block#toggle_line_numbers()
  AssertEqual 'always', g:fenced_code_block_show_line_numbers, 'Line numbers not toggled to always correctly'
  
  " Toggle to 'with_highlights'
  call fenced_code_block#toggle_line_numbers()
  AssertEqual 'with_highlights', g:fenced_code_block_show_line_numbers, 'Line numbers not toggled to with_highlights correctly'
  
  " Toggle back to 'never'
  call fenced_code_block#toggle_line_numbers()
  AssertEqual 'never', g:fenced_code_block_show_line_numbers, 'Line numbers not toggled to never correctly'
  
  " Restore original values
  let g:fenced_code_block_show_line_numbers = orig_show
  let g:fenced_code_block_line_number_method = orig_method

"===============================================================================
" Tests for changing highlight style
"===============================================================================

Execute (Test changing highlight style):
  " Test style change
  let orig_style = g:fenced_code_block_style
  
  call fenced_code_block#change_highlight_style('blue')
  AssertEqual 'blue', g:fenced_code_block_style
  
  " Restore
  let g:fenced_code_block_style = orig_style

"===============================================================================
" Tests for highlight groups at cursor
"===============================================================================

Execute (Test get_highlight_groups_at_cursor):
  " Create a temporary buffer with highlighted content
  new
  
  " Set up a test syntax
  syntax clear
  syntax match TestSyn1 /Test1/
  syntax match TestSyn2 /Test2/
  
  highlight TestSyn1 ctermfg=red guifg=red
  highlight TestSyn2 ctermfg=blue guifg=blue
  
  call setline(1, ['Test1', 'Test2', 'Normal text'])
  
  " Position cursor and get highlight groups
  call cursor(1, 1)
  let result1 = fenced_code_block#get_highlight_groups_at_cursor()
  
  call cursor(2, 1)
  let result2 = fenced_code_block#get_highlight_groups_at_cursor()
  
  call cursor(3, 1)
  let result3 = fenced_code_block#get_highlight_groups_at_cursor()
  
  " Clean up
  bwipeout!
  
  " Basic validation - we don't know what the exact results will be as it depends
  " on the Vim configuration, but we can check they're arrays
  Assert type(result1) == v:t_list, 'Highlight group result is not a list'
  Assert type(result2) == v:t_list, 'Highlight group result is not a list'
  Assert type(result3) == v:t_list, 'Highlight group result is not a list'

"===============================================================================
" Tests for helper functions
"===============================================================================

Execute (Test helper functions):
  " Test get_range_lines
  let range_lines = fenced_code_block#test_get_range_lines(1, 3)
  AssertEqual [1, 2, 3], range_lines
  
  " Test parse_single_line
  let single_line = fenced_code_block#test_parse_single_line("5")
  AssertEqual 5, single_line
  
  " Test invalid line
  let invalid_line = fenced_code_block#test_parse_single_line("invalid")
  AssertEqual 0, invalid_line

"===============================================================================
" Edge case tests
"===============================================================================

Execute (Test extract_highlight_spec with complex patterns):
  " Test with multiple attributes
  let line = '```python highlight="1-3" hl="5" class="syntax"'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '1-3', result, 'First highlight spec not correctly extracted'
  
  " Test with quote mismatch (should be empty)
  let line = '```python highlight="1-3'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '', result, 'Mismatched quotes should return empty string'
  
  " Test with empty quotes
  let line = '```python highlight=""'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '', result, 'Empty quotes not handled correctly'

Execute (Test parse_highlight_attribute with unusual formats):
  " Test with whitespace
  let spec = '  1  -  3  ,  5  '
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 2, 3, 5], result, 'Whitespace not handled correctly'
  
  " Test with invalid input (should handle gracefully)
  let spec = 'invalid'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [], result, 'Invalid input not handled gracefully'
  
  " Test with mixed valid and invalid
  let spec = '1,invalid,3'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 3], result, 'Mixed valid and invalid not handled correctly'

Execute (Test language detection edge cases):
  " Test with weird syntax
  AssertEqual 'c++', fenced_code_block#test_detect_language('```c++')
  AssertEqual 'f#', fenced_code_block#test_detect_language('```f#')
  AssertEqual 'typescript', fenced_code_block#test_detect_language('```typescript highlight="1"')
  AssertEqual 'js', fenced_code_block#test_detect_language('```{js}')
  
  " Extreme edge cases
  AssertEqual '', fenced_code_block#test_detect_language('````` weird fence')

"===============================================================================
" Cleanup and teardown tests
"===============================================================================

Execute (Test toggle and cleanup):
  " Test toggle function
  let b:highlighting_enabled = 1
  call fenced_code_block#toggle()
  Assert !b:highlighting_enabled, 'Toggle did not disable highlighting'
  
  call fenced_code_block#toggle()
  Assert b:highlighting_enabled, 'Toggle did not enable highlighting'
  
  " Test disable function
  call fenced_code_block#disable()
  
  " Create a buffer with matches to test clear_highlights
  new
  
  " Add some match IDs
  let w:fenced_code_block_match_ids = []
  let match_id = matchadd('Comment', '\%1l')
  call add(w:fenced_code_block_match_ids, match_id)
  
  " Call clear
  call fenced_code_block#clear_highlights()
  
  " Check if cleared
  AssertEqual [], w:fenced_code_block_match_ids, 'Match IDs not cleared'
  
  " Clean up
  bwipeout!

"===============================================================================
" Tests for start line number specification
"===============================================================================

Execute (Test extract_start_spec with double quotes):
  let line = '```python start="5"'
  let result = fenced_code_block#extract_start_spec(line)
  AssertEqual '5', result

Execute (Test extract_start_spec with single quotes):
  let line = "```python start='10'"
  let result = fenced_code_block#extract_start_spec(line)
  AssertEqual '10', result

Execute (Test extract_start_spec without quotes):
  let line = '```python start=15'
  let result = fenced_code_block#extract_start_spec(line)
  AssertEqual '15', result

Execute (Test extract_start_spec with alias):
  let line = '```python from="20"'
  let result = fenced_code_block#extract_start_spec(line)
  AssertEqual '20', result

Execute (Test extract_start_spec with no start keyword):
  let line = '```python'
  let result = fenced_code_block#extract_start_spec(line)
  AssertEqual '', result

Execute (Test parse_start_value with valid input):
  AssertEqual 5, fenced_code_block#parse_start_value('5')
  AssertEqual 10, fenced_code_block#parse_start_value('10')
  AssertEqual 1, fenced_code_block#parse_start_value('')

Execute (Test handling of reversed ranges):
  " Test parsing of reversed range
  let range_lines = fenced_code_block#test_get_range_lines(5, 3)
  AssertEqual [], range_lines, 'Reversed range should return empty array'
  
  " Test error handling for reversed range
  let b:mch_has_errors = 0
  let spec = '5-3'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [], result, 'Reversed range should be treated as invalid'
  
  " Create buffer with reversed range spec
  new
  call setline(1, [
        \ '# Test Markdown',
        \ '',
        \ '```python highlight="5-3"',
        \ 'def hello():',
        \ '    print("Hello")',
        \ '    return True',
        \ '```'
        \ ])
  
  " Apply highlighting
  call fenced_code_block#do_apply_highlighting()
  
  " Verify error was set
  Assert b:mch_has_errors, 'Reversed range should set error flag'
  
  " Clean up
  bwipeout!

After:
  " Reset global variables to avoid affecting other tests
  let g:fenced_code_block_keyword = 'highlight'
  let g:fenced_code_block_keyword_aliases = ['hl', 'hi']
  let g:fenced_code_block_fence_patterns = ['^```\(.*\)$', '^[\~]\{3,}\(.*\)$']
  let g:fenced_code_block_style = 'green'
  let g:fenced_code_block_error_style = 'red'
  let g:fenced_code_block_show_line_numbers = 0
  let g:fenced_code_block_line_number_method = 'auto'
  let g:fenced_code_block_update_delay = 0
  let g:fenced_code_block_debug = 0
  let g:fenced_code_block_custom = {}
