" Tests for fenced_code_block.vim functionality

" Setup global configuration
Before:
  " Set up test configuration
  let g:fenced_code_block_keyword = 'highlight'
  let g:fenced_code_block_keyword_aliases = ['hl', 'hi']
  let g:fenced_code_block_fence_patterns = ['^```\(.*\)$', '^~~~\(.*\)$']
  let g:fenced_code_block_style = 'green'
  let g:fenced_code_block_error_style = 'red'
  let g:fenced_code_block_show_line_numbers = 0
  let g:fenced_code_block_line_number_method = 'auto'
  let g:fenced_code_block_update_delay = 0
  let g:fenced_code_block_debug = 0
  let g:fenced_code_block_custom = {}

"===============================================================================
" Tests for highlight spec extraction
"===============================================================================

Execute (Test extract_highlight_spec with double quotes):
  let line = '```python highlight="1-3,5"'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '1-3,5', result

Execute (Test extract_highlight_spec with single quotes):
  let line = "```python highlight='2,4-6'"
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '2,4-6', result

Execute (Test extract_highlight_spec without quotes):
  let line = '```python highlight=1,3,5'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '1,3,5', result

Execute (Test extract_highlight_spec with alias):
  let line = '```python hl="1-3"'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '1-3', result

Execute (Test extract_highlight_spec with no highlight):
  let line = '```python'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '', result

"===============================================================================
" Tests for highlight attribute parsing
"===============================================================================

Execute (Test parse_highlight_attribute with comma-separated values):
  let spec = '1,3,5'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 3, 5], result

Execute (Test parse_highlight_attribute with range):
  let spec = '1-3'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 2, 3], result

Execute (Test parse_highlight_attribute with mixed values):
  let spec = '1-2,4,6-8'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 2, 4, 6, 7, 8], result

Execute (Test parse_highlight_attribute with colon format):
  let spec = '1-3:5'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 2, 3, 5], result

Execute (Test parse_highlight_attribute with spaces):
  let spec = '1 - 3, 5'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 2, 3, 5], result

Execute (Test parse_highlight_attribute with empty spec):
  let spec = ''
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [], result

"===============================================================================
" Tests for language detection
"===============================================================================

Execute (Test language detection for standard format):
  " We have to create a temporary function to access the script-local function
  function! TestDetectLanguage(line)
    " Use execute() to call script-local function
    return execute('echo s:detect_language("' . a:line . '")')->trim()
  endfunction

  AssertEqual 'python', TestDetectLanguage('```python')
  AssertEqual 'javascript', TestDetectLanguage('```javascript')
  AssertEqual 'ruby', TestDetectLanguage('``` ruby')
  AssertEqual 'shell-bash', TestDetectLanguage('```shell-bash')
  AssertEqual 'config.json', TestDetectLanguage('```config.json')
  AssertEqual 'php', TestDetectLanguage('```php highlight="1-3"')
  AssertEqual 'java', TestDetectLanguage('```{java}')
  AssertEqual '', TestDetectLanguage('```')

  " Clean up test function
  delfunction TestDetectLanguage

"===============================================================================
" Tests for complete parse-highlight workflow
"===============================================================================

Execute (Test full parse-highlight workflow):
  let line = '```python highlight="1,3-5"'
  let spec = fenced_code_block#extract_highlight_spec(line)
  let lines = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 3, 4, 5], lines

"===============================================================================
" Tests for style attribute parsing
"===============================================================================

Execute (Test parse_style_attributes):
  " Create a temporary function to access the script-local function
  function! TestParseStyleAttributes(...)
    let attrs = []
    for i in range(a:0)
      call add(attrs, a:000[i])
    endfor
    
    " Use execute() to call script-local function and parse the result
    let result_str = execute('echo s:parse_style_attributes(' . string(attrs) . ')')
    " Convert the printed dictionary to an actual dictionary
    let result = eval(result_str)
    return result
  endfunction
  
  let result = TestParseStyleAttributes('cterm', 'bold', 'ctermfg', 'red', 'ctermbg', 'black')
  AssertEqual 'bold', result.cterm
  AssertEqual 'red', result.ctermfg
  AssertEqual 'black', result.ctermbg
  
  " Clean up test function
  delfunction TestParseStyleAttributes

"===============================================================================
" Tests for line number method determination
"===============================================================================

Execute (Test determine_line_number_method):
  " Create a temporary function to access the script-local function
  function! TestDetermineLineNumberMethod()
    return execute('echo s:determine_line_number_method()')->trim()
  endfunction
  
  " Test with explicit method
  let g:fenced_code_block_line_number_method = 'sign'
  AssertEqual 'sign', TestDetermineLineNumberMethod()
  
  let g:fenced_code_block_line_number_method = 'prop'
  AssertEqual 'prop', TestDetermineLineNumberMethod()
  
  " Reset to auto - the actual result depends on Vim/Neovim version
  let g:fenced_code_block_line_number_method = 'auto'
  let result = TestDetermineLineNumberMethod()
  Assert result =~ '\(nvim\|prop\|sign\)'
  
  " Clean up test function
  delfunction TestDetermineLineNumberMethod

"===============================================================================
" Tests for code block finding
"===============================================================================

Execute (Test find_code_blocks function):
  " Create a temporary buffer with markdown content
  new
  call setline(1, [
        \ '# Test Markdown',
        \ '',
        \ '```python highlight="1,3"',
        \ 'def hello():',
        \ '    print("Hello")',
        \ '    return True',
        \ '```',
        \ '',
        \ 'Some text',
        \ '',
        \ '```javascript',
        \ 'function test() {',
        \ '  console.log("test");',
        \ '}',
        \ '```'
        \ ])

  " Create a function to access the script-local function's results
  function! TestFindCodeBlocks()
    let raw_result = execute('echo s:find_code_blocks()')
    " Parse the result string to get actual data structure
    " This is a bit complex due to Vim's string representation of nested structures
    let blocks = []
    
    " Use a placeholder pattern to extract each block separately
    let blocks_str = raw_result
    
    " For testing, we'll just check if blocks were found
    " and verify some key properties 
    return blocks_str =~ 'start_line'
          \ && blocks_str =~ 'language'
          \ && blocks_str =~ 'python'
          \ && blocks_str =~ 'javascript'
          \ && blocks_str =~ 'highlight_lines'
  endfunction
  
  Assert TestFindCodeBlocks()
  
  " Clean up
  bwipeout!
  delfunction TestFindCodeBlocks

"===============================================================================
" Tests for parse_highlight_spec integration
"===============================================================================

Execute (Test parse_highlight_spec with different formats):
  AssertEqual [1, 3], fenced_code_block#parse_highlight_spec('```python highlight="1,3"')
  AssertEqual [1, 2, 3], fenced_code_block#parse_highlight_spec('```python highlight="1-3"')
  AssertEqual [1, 2, 3, 5], fenced_code_block#parse_highlight_spec('```python highlight="1-3:5"')
  AssertEqual [], fenced_code_block#parse_highlight_spec('```python')

"===============================================================================
" Tests for highlight style application
"===============================================================================

Execute (Test apply_main_highlight_style):
  " Create a temporary function to test highlighting functions
  function! TestHighlightStyle(style)
    let g:fenced_code_block_style = a:style
    call fenced_code_block#setup_highlight_style()
    
    " Verify the highlight group exists
    let hl_id = hlID('MarkdownCodeHighlight')
    Assert hl_id > 0, 'Highlight group was not created'
    
    " For more detailed tests, get highlight attributes
    let hl_info = execute('hi MarkdownCodeHighlight')
    return hl_info
  endfunction

  " Test built-in styles
  let green_result = TestHighlightStyle('green')
  Assert green_result =~ 'ctermbg=green', 'Green style not applied correctly'
  Assert green_result =~ 'guibg=#00FF00', 'Green style GUI not applied correctly'
  
  let blue_result = TestHighlightStyle('blue')
  Assert blue_result =~ 'ctermbg=blue', 'Blue style not applied correctly'
  Assert blue_result =~ 'guibg=#0000FF', 'Blue style GUI not applied correctly'
  
  let bold_result = TestHighlightStyle('bold')
  Assert bold_result =~ 'cterm=bold', 'Bold style not applied correctly'
  Assert bold_result =~ 'gui=bold', 'Bold style GUI not applied correctly'
  
  " Clean up
  delfunction TestHighlightStyle

Execute (Test custom highlight styles):
  " Register a custom style
  let g:fenced_code_block_custom = {}
  call fenced_code_block#register_custom_style('test_custom', 'cterm', 'bold,underline', 'ctermfg', 'cyan', 'guifg', '#00FFFF')
  
  " Verify the style was registered
  Assert has_key(g:fenced_code_block_custom, 'test_custom')
  AssertEqual 'bold,underline', g:fenced_code_block_custom['test_custom']['cterm']
  AssertEqual 'cyan', g:fenced_code_block_custom['test_custom']['ctermfg']
  AssertEqual '#00FFFF', g:fenced_code_block_custom['test_custom']['guifg']
  
  " Apply the custom style
  let g:fenced_code_block_style = 'test_custom'
  call fenced_code_block#setup_highlight_style()
  
  " Verify the highlight group has the custom properties
  let hl_info = execute('hi MarkdownCodeHighlight')
  Assert hl_info =~ 'cterm=bold,underline', 'Custom cterm style not applied'
  Assert hl_info =~ 'ctermfg=cyan', 'Custom ctermfg style not applied'
  Assert hl_info =~ 'guifg=#00FFFF', 'Custom guifg style not applied'

"===============================================================================
" Tests for error highlight style
"===============================================================================

Execute (Test error highlight style):
  " Test the 'red' error style
  let g:fenced_code_block_error_style = 'red'
  call fenced_code_block#setup_highlight_style()
  
  let hl_info = execute('hi MarkdownCodeHighlightError')
  Assert hl_info =~ 'ctermbg=red', 'Red error style not applied correctly'
  Assert hl_info =~ 'guibg=#FF0000', 'Red error style GUI not applied correctly'
  
  " Test the 'reverse' error style
  let g:fenced_code_block_error_style = 'reverse'
  call fenced_code_block#setup_highlight_style()
  
  let hl_info = execute('hi MarkdownCodeHighlightError')
  Assert hl_info =~ 'cterm=reverse,bold', 'Reverse error style not applied correctly'
  Assert hl_info =~ 'gui=reverse,bold', 'Reverse error style GUI not applied correctly'

"===============================================================================
" Tests for style completion
"===============================================================================

Execute (Test style completion):
  " Register some custom styles for testing completion
  let g:fenced_code_block_custom = {}
  call fenced_code_block#register_custom_style('test_style1', 'cterm', 'bold')
  call fenced_code_block#register_custom_style('test_style2', 'cterm', 'italic')
  
  " Test completion with empty prefix
  let completions = fenced_code_block#complete_styles('', '', 0)
  Assert index(completions, 'green') >= 0, 'Built-in style missing from completions'
  Assert index(completions, 'test_style1') >= 0, 'Custom style missing from completions'
  
  " Test completion with prefix
  let completions = fenced_code_block#complete_styles('b', '', 0)
  Assert index(completions, 'blue') >= 0, 'Blue missing from prefix completions'
  Assert index(completions, 'bold') >= 0, 'Bold missing from prefix completions'
  Assert index(completions, 'green') < 0, 'Green incorrectly included in prefix completions'

"===============================================================================
" Tests for highlight line specification validation
"===============================================================================

Execute (Test validate_highlight_lines):
  " Create helper function to test validation
  function! TestValidateHighlightLines(lines, block_size, start_line)
    " Reset the error flag
    let b:mch_has_errors = 0
    
    " Call the validation function
    execute 'call s:validate_highlight_lines(' . string(a:lines) . ', ' . a:block_size . ', ' . a:start_line . ')'
    
    " Return the error flag
    return b:mch_has_errors
  endfunction
  
  " Test valid line numbers
  Assert !TestValidateHighlightLines([1, 2, 3], 5, 10), 'Valid line numbers incorrectly flagged as invalid'
  
  " Test invalid line numbers
  Assert TestValidateHighlightLines([1, 6, 3], 5, 10), 'Invalid line number not detected'
  Assert TestValidateHighlightLines([0, 2, 3], 5, 10), 'Zero line number not detected as invalid'
  Assert TestValidateHighlightLines([-1, 2, 3], 5, 10), 'Negative line number not detected as invalid'
  
  " Clean up
  delfunction TestValidateHighlightLines

"===============================================================================
" Tests for line number toggling
"===============================================================================

Execute (Test line number toggling functions):
  " Create helper function to test enabling/disabling
  function! TestLineNumberToggle()
    " Store original values to restore later
    let orig_show = g:fenced_code_block_show_line_numbers
    let orig_method = g:fenced_code_block_line_number_method
    
    " Test enabling line numbers
    let g:fenced_code_block_show_line_numbers = 0
    let g:fenced_code_block_line_number_method = 'sign'
    
    " Call the toggle function
    call fenced_code_block#toggle_line_numbers()
    
    " Check if line numbers are now enabled
    let result1 = g:fenced_code_block_show_line_numbers
    
    " Call the toggle function again
    call fenced_code_block#toggle_line_numbers()
    
    " Check if line numbers are now disabled
    let result2 = g:fenced_code_block_show_line_numbers
    
    " Restore original values
    let g:fenced_code_block_show_line_numbers = orig_show
    let g:fenced_code_block_line_number_method = orig_method
    
    return [result1, result2]
  endfunction
  
  let [enabled, disabled] = TestLineNumberToggle()
  AssertEqual 1, enabled, 'Line numbers not enabled correctly'
  AssertEqual 0, disabled, 'Line numbers not disabled correctly'
  
  " Clean up
  delfunction TestLineNumberToggle

"===============================================================================
" Tests for changing highlight style
"===============================================================================

Execute (Test changing highlight style):
  " Test style change
  let orig_style = g:fenced_code_block_style
  
  call fenced_code_block#change_highlight_style('blue')
  AssertEqual 'blue', g:fenced_code_block_style
  
  let hl_info = execute('hi MarkdownCodeHighlight')
  Assert hl_info =~ 'ctermbg=blue', 'Style change did not apply blue'
  
  " Restore
  let g:fenced_code_block_style = orig_style

"===============================================================================
" Tests for highlight groups at cursor
"===============================================================================

Execute (Test get_highlight_groups_at_cursor):
  " Create a temporary buffer with highlighted content
  new
  
  " Set up a test syntax
  syntax clear
  syntax match TestSyn1 /Test1/
  syntax match TestSyn2 /Test2/
  
  highlight TestSyn1 ctermfg=red guifg=red
  highlight TestSyn2 ctermfg=blue guifg=blue
  
  call setline(1, ['Test1', 'Test2', 'Normal text'])
  
  " Position cursor and get highlight groups
  call cursor(1, 1)
  let result1 = fenced_code_block#get_highlight_groups_at_cursor()
  
  call cursor(2, 1)
  let result2 = fenced_code_block#get_highlight_groups_at_cursor()
  
  call cursor(3, 1)
  let result3 = fenced_code_block#get_highlight_groups_at_cursor()
  
  " Clean up
  bwipeout!
  
  " Check results
  Assert index(result1, 'TestSyn1') >= 0 || empty(result1), 'TestSyn1 not correctly identified'
  Assert index(result2, 'TestSyn2') >= 0 || empty(result2), 'TestSyn2 not correctly identified'

"===============================================================================
" Integration Tests
"===============================================================================

Execute (Test integration: full workflow):
  " Set up test environment
  let g:fenced_code_block_keyword = 'highlight'
  let g:fenced_code_block_style = 'green'
  let g:fenced_code_block_show_line_numbers = 0
  
  " Create a test buffer with a code block
  new
  call setline(1, [
        \ '# Test Document',
        \ '',
        \ '```python highlight="1,3-4"',
        \ 'def test_function():',
        \ '    # This is a comment',
        \ '    print("Hello, world!")',
        \ '    return True',
        \ '```'
        \ ])
  
  " Enable highlighting
  let b:highlighting_enabled = 1
  call fenced_code_block#enable()
  
  " Test if the highlight group exists
  let hl_id = hlID('MarkdownCodeHighlight')
  Assert hl_id > 0, 'Highlight group was not created during integration test'
  
  " Clean up
  bwipeout!

"===============================================================================
" Helper function tests
"===============================================================================

Execute (Test helper functions):
  " Test get_range_lines
  let range_lines = execute('echo s:get_range_lines(1, 3)')->trim()
  AssertEqual '[1, 2, 3]', range_lines
  
  " Test parse_single_line
  let single_line = execute('echo s:parse_single_line("5")')->trim()
  AssertEqual '5', single_line
  
  " Test invalid line
  let invalid_line = execute('echo s:parse_single_line("invalid")')->trim()
  AssertEqual '0', invalid_line

"===============================================================================
" Edge case tests
"===============================================================================

Execute (Test extract_highlight_spec with complex patterns):
  " Test with multiple attributes
  let line = '```python highlight="1-3" hl="5" class="syntax"'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '1-3', result, 'First highlight spec not correctly extracted'
  
  " Test with quote mismatch (should be empty)
  let line = '```python highlight="1-3'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '', result, 'Mismatched quotes should return empty string'
  
  " Test with empty quotes
  let line = '```python highlight=""'
  let result = fenced_code_block#extract_highlight_spec(line)
  AssertEqual '', result, 'Empty quotes not handled correctly'

Execute (Test parse_highlight_attribute with unusual formats):
  " Test with whitespace
  let spec = '  1  -  3  ,  5  '
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 2, 3, 5], result, 'Whitespace not handled correctly'
  
  " Test with invalid input (should handle gracefully)
  let spec = 'invalid'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [], result, 'Invalid input not handled gracefully'
  
  " Test with mixed valid and invalid
  let spec = '1,invalid,3'
  let result = fenced_code_block#parse_highlight_attribute(spec)
  AssertEqual [1, 3], result, 'Mixed valid and invalid not handled correctly'

Execute (Test language detection edge cases):
  " Create helper function
  function! TestDetectLanguage(line)
    return execute('echo s:detect_language("' . a:line . '")')->trim()
  endfunction
  
  " Test with weird syntax
  AssertEqual 'c++', TestDetectLanguage('```c++')
  AssertEqual 'f#', TestDetectLanguage('```f#')
  AssertEqual 'typescript', TestDetectLanguage('```typescript highlight="1"')
  AssertEqual 'js', TestDetectLanguage('```{js}')
  
  " Extreme edge cases
  AssertEqual '', TestDetectLanguage('````` weird fence')
  
  " Clean up
  delfunction TestDetectLanguage

"===============================================================================
" Cleanup and teardown tests
"===============================================================================

Execute (Test toggle and cleanup):
  " Test toggle function
  let b:highlighting_enabled = 1
  call fenced_code_block#toggle()
  Assert !b:highlighting_enabled, 'Toggle did not disable highlighting'
  
  call fenced_code_block#toggle()
  Assert b:highlighting_enabled, 'Toggle did not enable highlighting'
  
  " Test disable function
  call fenced_code_block#disable()
  
  " Create a buffer with matches to test clear_highlights
  new
  
  " Add some match IDs
  let w:fenced_code_block_match_ids = []
  let match_id = matchadd('Comment', '\%1l')
  call add(w:fenced_code_block_match_ids, match_id)
  
  " Call clear
  call fenced_code_block#clear_highlights()
  
  " Check if cleared
  AssertEqual [], w:fenced_code_block_match_ids, 'Match IDs not cleared'
  
  " Clean up
  bwipeout!

After:
  " Reset global variables to avoid affecting other tests
  let g:fenced_code_block_keyword = 'highlight'
  let g:fenced_code_block_keyword_aliases = ['hl', 'hi']
  let g:fenced_code_block_fence_patterns = ['^```\(.*\)$', '^~~~\(.*\)$']
  let g:fenced_code_block_style = 'green'
  let g:fenced_code_block_error_style = 'red'
  let g:fenced_code_block_show_line_numbers = 0
  let g:fenced_code_block_line_number_method = 'auto'
  let g:fenced_code_block_update_delay = 0
  let g:fenced_code_block_debug = 0
  let g:fenced_code_block_custom = {}
